var documenterSearchIndex = {"docs":
[{"location":"user_guide/basic_plotting/#Basic-Plotting","page":"Basic Plotting","title":"Basic Plotting","text":"Learn how to create and customize chord diagrams.","category":"section"},{"location":"user_guide/basic_plotting/#Simple-Plot","page":"Basic Plotting","title":"Simple Plot","text":"fig = Figure(size=(800, 800))\nax = Axis(fig[1,1], title=\"My Chord Diagram\")\nchordplot!(ax, cooc)\nsetup_chord_axis!(ax)\nfig\n\n<img src=\"assets/examples/basic.png\" alt=\"Basic Plot\" style=\"max-width: 600px;\"/>","category":"section"},{"location":"user_guide/basic_plotting/#Standalone-Plot","page":"Basic Plotting","title":"Standalone Plot","text":"You can also create a plot without explicitly creating an axis:\n\nfig, ax, plt = chordplot(cooc)\nsetup_chord_axis!(ax)\nfig","category":"section"},{"location":"user_guide/basic_plotting/#Essential-Setup","page":"Basic Plotting","title":"Essential Setup","text":"Always call setup_chord_axis! after plotting to:\n\nSet equal aspect ratio\nRemove axis decorations\nSet appropriate limits\n\nsetup_chord_axis!(ax; padding=0.2)  # padding controls margin around plot","category":"section"},{"location":"user_guide/basic_plotting/#Plotting-from-DataFrame","page":"Basic Plotting","title":"Plotting from DataFrame","text":"You can plot directly from a DataFrame:\n\nchordplot!(ax, df, [:V, :D, :J])\n\nThis is equivalent to:\n\ncooc = cooccurrence_matrix(df, [:V, :D, :J])\nchordplot!(ax, cooc)","category":"section"},{"location":"user_guide/filtering/#Filtering-and-Data-Management","page":"Filtering","title":"Filtering and Data Management","text":"Filter data to reduce clutter and focus on important relationships.","category":"section"},{"location":"user_guide/filtering/#Filtering-Small-Segments","page":"Filtering","title":"Filtering Small Segments","text":"When you have many labels with small co-occurrence values, they can cluster together and overlap:\n\nchordplot!(ax, cooc;\n    min_arc_flow = 10  # Only show arcs with total flow >= 10\n)\n\nThis removes both the arc and its label, reducing clutter.\n\n<img src=\"assets/examples/filtered.png\" alt=\"Filtered Data\" style=\"max-width: 600px;\"/>\n\nWhat this shows: This example demonstrates filtering using filter_top_n(), which keeps only the top 8 labels by total flow (sum of all connections). The original dataset had many more labels (A1-A8, B1-B5, C1-C4), but only the 8 most connected labels are displayed. Filtering helps focus attention on the strongest relationships and is particularly useful when working with large datasets where many labels have only weak connections that would otherwise create visual clutter.","category":"section"},{"location":"user_guide/filtering/#Filtering-Before-Plotting","page":"Filtering","title":"Filtering Before Plotting","text":"Filter the data before plotting:\n\n# Keep only top N labels by total flow\ncooc_top = filter_top_n(cooc, 15)\n\n# Filter by minimum co-occurrence value\ncooc_filtered = filter_by_threshold(cooc, 5)\n\n# Normalize to frequencies\ncooc_norm = normalize(cooc)","category":"section"},{"location":"user_guide/filtering/#Filtering-Ribbons","page":"Filtering","title":"Filtering Ribbons","text":"Filter ribbons in the layout:\n\nlayout = compute_layout(cooc)\n\n# Filter by minimum value\nlayout_filtered = filter_ribbons(layout, 5)\n\n# Keep only top N ribbons\nlayout_top = filter_ribbons_top_n(layout, 20)","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete reference for all exported functions and types.","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Data-Management","page":"API Reference","title":"Data Management","text":"","category":"section"},{"location":"api/#Layout-Functions","page":"API Reference","title":"Layout Functions","text":"","category":"section"},{"location":"api/#Color-Functions","page":"API Reference","title":"Color Functions","text":"categorical_colors(n::Int; palette=:default) - Create n distinguishable colors using Makie's default categorical palette (same as AlgebraOfGraphics uses - Wong colors, colorblind-friendly).","category":"section"},{"location":"api/#Geometry-Functions","page":"API Reference","title":"Geometry Functions","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"These functions are exported but don't have separate docstrings:\n\nnlabels(cooc) - Number of labels in co-occurrence matrix\nngroups(cooc) - Number of groups  \ntotal_flow(cooc, label_idx) - Total flow for a label (sum of all connections)\nget_group(cooc, label_idx) - Get group symbol for a label\nnarcs(layout) - Number of arcs in layout\nnribbons(layout) - Number of ribbons in layout\narc_span(arc) - Span angle of an arc\narc_midpoint(arc) - Midpoint angle of an arc\nendpoint_span(endpoint) - Span of a ribbon endpoint\nendpoint_midpoint(endpoint) - Midpoint of a ribbon endpoint\nis_self_loop(ribbon) - Check if ribbon is a self-loop\nresolve_arc_color(scheme, arc, cooc) - Resolve color for an arc\nresolve_ribbon_color(scheme, ribbon, cooc) - Resolve color for a ribbon\nchordplot!(ax, cooc; kwargs...) - In-place version of chordplot","category":"section"},{"location":"api/#ChordPlots.cooccurrence_matrix","page":"API Reference","title":"ChordPlots.cooccurrence_matrix","text":"cooccurrence_matrix(df::DataFrame, columns::Vector{Symbol}; normalize=false)\n\nCompute a co-occurrence matrix from a DataFrame.\n\nEach row in the DataFrame represents one observation. Labels from different columns that appear in the same row are considered co-occurring.\n\nArguments\n\ndf::DataFrame: Input data\ncolumns::Vector{Symbol}: Column names to analyze\n\nKeywords\n\nnormalize::Bool=false: If true, normalize counts to frequencies\n\nReturns\n\nCoOccurrenceMatrix: Matrix of co-occurrence counts/frequencies\n\nExample\n\ndf = DataFrame(\n    V_call = [\"IGHV1-2*01\", \"IGHV1-2*01\", \"IGHV3-23*01\"],\n    D_call = [\"IGHD2-2*01\", \"IGHD3-10*01\", \"IGHD2-2*01\"],\n    J_call = [\"IGHJ6*01\", \"IGHJ6*01\", \"IGHJ4*02\"]\n)\ncooc = cooccurrence_matrix(df, [:V_call, :D_call, :J_call])\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.chordplot","page":"API Reference","title":"ChordPlots.chordplot","text":"chordplot(cooc::CoOccurrenceMatrix)\nchordplot!(ax, cooc::CoOccurrenceMatrix)\n\nCreate a chord diagram from co-occurrence data.\n\nAttributes\n\ninner_radius = 0.92: Inner radius for ribbons (closer to outer for less wasted space)\nouter_radius = 1.0: Outer radius for arcs\narc_width = 0.08: Width of arc segments\ngap_fraction = 0.03: Gap between arcs as fraction of circle\nribbon_alpha = 0.65: Transparency for ribbons\nribbon_alpha_by_value = false: If true, scale opacity by ribbon value (min 10%, larger ribbons more visible)\nribbon_alpha_scale = :linear: Scaling method for value-based opacity (:linear default, :log for better distribution of small integers)\nribbon_tension = 0.5: Bezier curve tension (0=straight, 1=tight)\nshow_labels = true: Show labels\nlabel_offset = 0.12: Distance from arc to label (increase for longer labels to avoid overlap)\nlabel_fontsize = 10: Label font size\nrotate_labels = true: Rotate labels to follow arcs (prevents upside-down text)\nlabel_justify = :inside: Label justification (:inside aligns toward circle center, :outside aligns away)\nmin_arc_flow = 0: Filter out arcs and labels with total flow below this value (helps reduce overlap from many small segments)\ncolorscheme = :group: Color scheme (:group, :categorical, or AbstractColorScheme)\narc_strokewidth = 0.5: Arc border width\narc_strokecolor = :black: Arc border color\narc_alpha = 0.9: Transparency for arcs (slight transparency for modern look)\nsort_by = :group: How to sort arcs (:group, :value, :none)\nmin_ribbon_value = 0: Hide ribbons below this value\n\nExample\n\nusing CairoMakie, ChordPlots, DataFrames\n\ndf = DataFrame(\n    V_call = [\"V1\", \"V1\", \"V2\", \"V2\", \"V3\"],\n    D_call = [\"D1\", \"D2\", \"D1\", \"D2\", \"D1\"],\n    J_call = [\"J1\", \"J1\", \"J2\", \"J2\", \"J1\"]\n)\n\ncooc = cooccurrence_matrix(df, [:V_call, :D_call, :J_call])\nfig, ax, plt = chordplot(cooc)\n\n\n\n\n\nchordplot(df::DataFrame, columns; kwargs...)\n\nCreate chord plot directly from DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.setup_chord_axis!","page":"API Reference","title":"ChordPlots.setup_chord_axis!","text":"setup_chord_axis!(ax::Axis)\n\nConfigure axis for chord plot display (equal aspect, no decorations).\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.compute_layout","page":"API Reference","title":"ChordPlots.compute_layout","text":"compute_layout(cooc::CoOccurrenceMatrix{T, S}, config::LayoutConfig=LayoutConfig()) where {T, S}\n\nCompute the complete layout for a chord diagram.\n\nAlgorithm\n\nCalculate total flow for each label\nAllocate angular width proportional to flow\nAssign arc positions\nGenerate ribbon endpoints based on co-occurrence values\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.filter_top_n","page":"API Reference","title":"ChordPlots.filter_top_n","text":"filter_top_n(cooc::CoOccurrenceMatrix, n::Int)\n\nKeep only the top n labels by total flow.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.filter_by_threshold","page":"API Reference","title":"ChordPlots.filter_by_threshold","text":"filter_by_threshold(cooc::CoOccurrenceMatrix{T, S}, min_value::T) where {T, S}\n\nCreate a new CoOccurrenceMatrix with values below threshold set to zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.normalize","page":"API Reference","title":"ChordPlots.normalize","text":"normalize(cooc::CoOccurrenceMatrix{T, S}) where {T, S}\n\nReturn a normalized version where all values sum to 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.CoOccurrenceMatrix","page":"API Reference","title":"ChordPlots.CoOccurrenceMatrix","text":"CoOccurrenceMatrix{T<:Real, S<:AbstractString}\n\nStores co-occurrence counts between labels with group information.\n\nType Parameters\n\nT: Numeric type for counts (enables Integer or Float)\nS: String type for labels\n\nFields\n\nmatrix::Matrix{T}: Symmetric co-occurrence matrix\nlabels::Vector{S}: Combined list of all labels\ngroups::Vector{GroupInfo{S}}: Group information\nlabel_to_index::Dict{S, Int}: Fast label lookup\n\nExample\n\ncooc = CoOccurrenceMatrix(df, [:V_call, :D_call, :J_call])\ncooc[\"IGHV1-2*01\", \"IGHD2-2*01\"]  # Get co-occurrence count\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.filter_ribbons","page":"API Reference","title":"ChordPlots.filter_ribbons","text":"filter_ribbons(layout::ChordLayout, min_value::Real)\n\nFilter ribbons below a minimum value threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.filter_ribbons_top_n","page":"API Reference","title":"ChordPlots.filter_ribbons_top_n","text":"filter_ribbons_top_n(layout::ChordLayout, n::Int)\n\nKeep only the top n ribbons by value.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.LayoutConfig","page":"API Reference","title":"ChordPlots.LayoutConfig","text":"LayoutConfig{T<:Real}\n\nConfiguration for layout computation.\n\nFields\n\ninner_radius::T: Inner radius for ribbon attachment\nouter_radius::T: Outer radius for arcs\ngap_fraction::T: Fraction of circle to use for gaps between arcs\nstart_angle::T: Starting angle (0 = right, π/2 = top)\ndirection::Int: 1 for counterclockwise, -1 for clockwise\nsort_by::Symbol: How to sort arcs (:group, :value, :none)\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.ChordLayout","page":"API Reference","title":"ChordPlots.ChordLayout","text":"ChordLayout{T<:Real}\n\nComplete layout information for rendering a chord diagram.\n\nFields\n\narcs::Vector{ArcSegment{T}}: Arc segments for each label\nribbons::Vector{Ribbon{T}}: All ribbons\ninner_radius::T: Inner radius for ribbons\nouter_radius::T: Outer radius for arcs\ngap_angle::T: Gap between adjacent arcs\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.group_colors","page":"API Reference","title":"ChordPlots.group_colors","text":"group_colors(cooc::CoOccurrenceMatrix; palette=:default)\n\nCreate a color scheme based on groups using Makie's default categorical palette (same as AlgebraOfGraphics uses - Wong colors, colorblind-friendly).\n\nArguments\n\npalette::Symbol: Color palette style (:default for Makie/AoG palette, :modern for custom)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.gradient_colors","page":"API Reference","title":"ChordPlots.gradient_colors","text":"gradient_colors(; colormap=:viridis, min_val=0.0, max_val=1.0)\n\nCreate a gradient-based color scheme.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.with_alpha","page":"API Reference","title":"ChordPlots.with_alpha","text":"with_alpha(color::Colorant, alpha::Real)\n\nReturn color with specified alpha value.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.darken","page":"API Reference","title":"ChordPlots.darken","text":"darken(color::Colorant, factor::Real=0.2)\n\nDarken a color by the given factor.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.lighten","page":"API Reference","title":"ChordPlots.lighten","text":"lighten(color::Colorant, factor::Real=0.2)\n\nLighten a color by the given factor.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.GroupColorScheme","page":"API Reference","title":"ChordPlots.GroupColorScheme","text":"GroupColorScheme{C<:Colorant}\n\nAssigns colors based on label groups.\n\nFields\n\ngroup_colors::Dict{Symbol, C}: Color for each group\ndefault_color::C: Fallback color\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.CategoricalColorScheme","page":"API Reference","title":"ChordPlots.CategoricalColorScheme","text":"CategoricalColorScheme{C<:Colorant}\n\nAssigns distinct colors to each label.\n\nFields\n\ncolors::Vector{C}: Color palette\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.GradientColorScheme","page":"API Reference","title":"ChordPlots.GradientColorScheme","text":"GradientColorScheme\n\nColors based on a gradient (e.g., by value).\n\nFields\n\ncolormap::Symbol: Makie colormap name\nrange::Tuple{Float64, Float64}: Value range for mapping\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.arc_points","page":"API Reference","title":"ChordPlots.arc_points","text":"arc_points(start_angle::Real, end_angle::Real, radius::Real; n_points::Int=50)\n\nGenerate points along an arc.\n\nArguments\n\nstart_angle: Start angle in radians\nend_angle: End angle in radians\nradius: Arc radius\nn_points: Number of points (more = smoother)\n\nReturns\n\nVector{Point2f}: Points along the arc\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.arc_polygon","page":"API Reference","title":"ChordPlots.arc_polygon","text":"arc_polygon(inner_radius::Real, outer_radius::Real, start_angle::Real, end_angle::Real; n_points::Int=30)\n\nGenerate a filled arc (annular sector) as a polygon.\n\nReturns points forming a closed polygon: outer arc → inner arc (reversed) → close.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.ribbon_path","page":"API Reference","title":"ChordPlots.ribbon_path","text":"ribbon_path(ribbon::Ribbon, radius::Real; n_bezier::Int=30, tension::Real=0.5)\n\nGenerate the path for a ribbon connecting two arcs.\n\nThe ribbon consists of:\n\nSource arc segment\nBezier curve to target\nTarget arc segment  \nBezier curve back to source\n\nArguments\n\nribbon: Ribbon geometry specification\nradius: Radius where ribbons attach\nn_bezier: Points per Bezier curve\ntension: Control point tension (0 = straight, 1 = tight curves)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.ribbon_paths","page":"API Reference","title":"ChordPlots.ribbon_paths","text":"ribbon_paths(ribbons::Vector{Ribbon{T}}, radius::Real; kwargs...)\n\nGenerate paths for multiple ribbons.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.label_position","page":"API Reference","title":"ChordPlots.label_position","text":"label_position(arc::ArcSegment, radius::Real, offset::Real; rotate::Bool=true, justify::Symbol=:inside)\n\nCalculate position for an arc's label.\n\nArguments\n\narc: Arc segment\nradius: Outer radius of the arc\noffset: Distance from arc to label\nrotate: Whether to rotate label to follow arc\njustify: Label justification (:inside aligns toward circle center, :outside aligns away)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.label_positions","page":"API Reference","title":"ChordPlots.label_positions","text":"label_positions(arcs::Vector{ArcSegment{T}}, radius::Real, offset::Real; kwargs...)\n\nCalculate positions for all arc labels.\n\nKeyword Arguments\n\nrotate::Bool=true: Whether to rotate labels to follow arcs\njustify::Symbol=:inside: Label justification (:inside or :outside)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.ArcSegment","page":"API Reference","title":"ChordPlots.ArcSegment","text":"ArcSegment{T<:Real}\n\nRepresents an arc on the outer circle for a single label.\n\nFields\n\nlabel_idx::Int: Index into the label array\nstart_angle::T: Starting angle in radians\nend_angle::T: Ending angle in radians  \nvalue::T: Total flow value (determines arc width)\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.RibbonEndpoint","page":"API Reference","title":"ChordPlots.RibbonEndpoint","text":"RibbonEndpoint{T<:Real}\n\nRepresents one end of a ribbon attached to an arc.\n\nFields\n\nlabel_idx::Int: Which label this endpoint is on\nstart_angle::T: Start angle on the arc\nend_angle::T: End angle on the arc\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.Ribbon","page":"API Reference","title":"ChordPlots.Ribbon","text":"Ribbon{T<:Real}\n\nRepresents a ribbon connecting two labels.\n\nFields\n\nsource::RibbonEndpoint{T}: Source endpoint\ntarget::RibbonEndpoint{T}: Target endpoint\nvalue::T: Co-occurrence value\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.RibbonPath","page":"API Reference","title":"ChordPlots.RibbonPath","text":"RibbonPath\n\nStores the complete path for rendering a ribbon.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.GroupInfo","page":"API Reference","title":"ChordPlots.GroupInfo","text":"GroupInfo{S<:AbstractString}\n\nInformation about a group of labels (e.g., V calls, D calls, J calls).\n\nFields\n\nname::Symbol: Group identifier\nlabels::Vector{S}: Labels belonging to this group\nindices::UnitRange{Int}: Index range in the combined label list\n\n\n\n\n\n","category":"type"},{"location":"user_guide/layout/#Layout-Configuration","page":"Layout Configuration","title":"Layout Configuration","text":"Advanced control over chord diagram layout.","category":"section"},{"location":"user_guide/layout/#Custom-Layout","page":"Layout Configuration","title":"Custom Layout","text":"Compute layouts manually for advanced control:\n\nconfig = LayoutConfig(\n    inner_radius = 0.75,    # Ribbon attachment radius\n    outer_radius = 1.0,     # Arc outer radius\n    gap_fraction = 0.05,    # Gap between arcs\n    start_angle = π/2,      # Start at top (0 = right)\n    direction = 1,          # 1 = counterclockwise, -1 = clockwise\n    sort_by = :group        # :group, :value, or :none\n)\n\nlayout = compute_layout(cooc, config)\n\nWhat is a custom layout? A custom layout allows you to control how labels are arranged around the circle, how arcs are sized, and the spacing between elements. This gives you fine-grained control over the visual appearance beyond the default settings.\n\n<img src=\"assets/examples/layout.png\" alt=\"Custom Layout\" style=\"max-width: 600px;\"/>\n\nWhat this shows: This example demonstrates several layout customizations applied together:\n\nsort_by=:value - Labels are sorted by their total flow (largest first), so the most connected labels get the largest arcs and appear first. Compare this to the basic example where labels are sorted by group - here, the most important labels are visually emphasized.\ninner_radius=0.85 - Ribbons start closer to the center (default is 0.92), creating more space between ribbon endpoints and the outer circle. This gives a different visual balance and can help when you have many connections.\ngap_fraction=0.05 - Slightly larger gaps between arc segments (default is 0.03), making individual arcs more distinct and easier to identify.\n\nThese settings work together to create a layout that emphasizes the most important labels and creates a different visual hierarchy compared to the default group-sorted layout.","category":"section"},{"location":"user_guide/layout/#Sorting-Options","page":"Layout Configuration","title":"Sorting Options","text":":group - Keep groups together, sort within groups by value (default)\n:value - Sort all labels by total flow (descending)\n:none - Use original order","category":"section"},{"location":"user_guide/layout/#Accessing-Layout-Data","page":"Layout Configuration","title":"Accessing Layout Data","text":"layout = compute_layout(cooc)\n\n# Get information\nnarcs(layout)      # Number of arcs\nnribbons(layout)   # Number of ribbons\n\n# Access arcs\nfor arc in layout.arcs\n    println(\"Label $(arc.label_idx): $(arc.start_angle) to $(arc.end_angle)\")\nend\n\n# Access ribbons\nfor ribbon in layout.ribbons\n    println(\"Connection: $(ribbon.source.label_idx) → $(ribbon.target.label_idx), value: $(ribbon.value)\")\nend","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide will help you create your first chord diagram with ChordPlots.jl.","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/mashu/ChordPlots.jl\")","category":"section"},{"location":"getting_started/#Your-First-Chord-Diagram","page":"Getting Started","title":"Your First Chord Diagram","text":"using CairoMakie, ChordPlots, DataFrames\n\n# Create sample data\ndf = DataFrame(\n    V = [\"V1\", \"V1\", \"V2\", \"V2\"],\n    D = [\"D1\", \"D2\", \"D1\", \"D2\"],\n    J = [\"J1\", \"J1\", \"J2\", \"J2\"]\n)\n\n# Create co-occurrence matrix\ncooc = cooccurrence_matrix(df, [:V, :D, :J])\n\n# Create plot\nfig = Figure(size=(800, 800))\nax = Axis(fig[1,1], title=\"My First Chord Diagram\")\nchordplot!(ax, cooc)\nsetup_chord_axis!(ax)\nfig\n\n<img src=\"assets/examples/basic.png\" alt=\"Basic Chord Diagram\" style=\"max-width: 600px;\"/>\n\nWhat you see: This basic chord diagram shows the default visualization. Labels (V1, V2, V3, D1, D2, J1, J2) are arranged around the circle, grouped by their category. The colored arcs represent each label, and the curved ribbons connect labels that appear together in the data. Ribbon thickness indicates how frequently labels co-occur. Colors are assigned by group (all V labels share one color, all D labels another, etc.), using the default Wong color palette for a professional, colorblind-friendly appearance.","category":"section"},{"location":"getting_started/#What-Happens-Here?","page":"Getting Started","title":"What Happens Here?","text":"Data Preparation: Each row in the DataFrame represents one observation with multiple categorical variables\nCo-occurrence Matrix: cooccurrence_matrix counts how often labels from different groups appear together\nPlotting: chordplot! creates the visual representation\nSetup: setup_chord_axis! configures the axis for optimal display","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Learn about creating co-occurrence data\nExplore customization options\nSee example visualizations","category":"section"},{"location":"user_guide/customization/#Customization","page":"Customization","title":"Customization","text":"Customize the appearance of your chord diagrams.","category":"section"},{"location":"user_guide/customization/#Layout-Parameters","page":"Customization","title":"Layout Parameters","text":"Control the overall layout:\n\nchordplot!(ax, cooc;\n    inner_radius = 0.92,    # Inner radius for ribbons\n    outer_radius = 1.0,     # Outer radius for arcs\n    arc_width = 0.08,       # Width of arc segments\n    gap_fraction = 0.03,    # Gap between arcs\n    sort_by = :group        # :group, :value, or :none\n)","category":"section"},{"location":"user_guide/customization/#Ribbon-Styling","page":"Customization","title":"Ribbon Styling","text":"Control ribbon appearance:\n\nchordplot!(ax, cooc;\n    ribbon_alpha = 0.65,              # Transparency\n    ribbon_alpha_by_value = true,     # Scale opacity by value\n    ribbon_alpha_scale = :linear,      # :linear or :log\n    ribbon_tension = 0.5,              # Bezier curve tension\n    min_ribbon_value = 0               # Hide ribbons below this value\n)\n\n<img src=\"assets/examples/opacity.png\" alt=\"Value-based Opacity\" style=\"max-width: 600px;\"/>\n\nWhat this shows: This example uses ribbon_alpha_by_value=true to make ribbon opacity vary based on co-occurrence value. Compare this to the basic example: here, thicker ribbons (higher co-occurrence counts) appear more opaque and prominent, while thinner ribbons (lower counts) are more transparent. This creates a visual hierarchy where the most important connections stand out clearly, while weaker connections fade into the background. The effect is subtle but effective - it helps guide the eye to the strongest relationships in your data.\n\nValue-based opacity makes larger connections more visible:\n\nMinimum opacity: 10% (never fully invisible)\nMaximum opacity: ribbon_alpha\nUse :log scale for better distribution with small integer values","category":"section"},{"location":"user_guide/customization/#Arc-Styling","page":"Customization","title":"Arc Styling","text":"Customize arc segments:\n\nchordplot!(ax, cooc;\n    arc_width = 0.08,\n    arc_alpha = 0.9,\n    arc_strokewidth = 0.5,\n    arc_strokecolor = :black\n)","category":"section"},{"location":"user_guide/customization/#Label-Customization","page":"Customization","title":"Label Customization","text":"Control labels:\n\nchordplot!(ax, cooc;\n    show_labels = true,\n    label_offset = 0.12,        # Distance from arc\n    label_fontsize = 10,\n    label_color = :black,\n    rotate_labels = true,        # Rotate to follow arc\n    label_justify = :inside     # :inside or :outside\n)\n\nTips for long labels:\n\nIncrease label_offset (e.g., 0.18) to move labels further out\nUse label_justify = :inside to align toward circle center\nAdjust label_fontsize based on figure size","category":"section"},{"location":"user_guide/colors/#Color-Schemes","page":"Color Schemes","title":"Color Schemes","text":"ChordPlots uses modern, professional color palettes by default.","category":"section"},{"location":"user_guide/colors/#Group-based-Colors-(Default)","page":"Color Schemes","title":"Group-based Colors (Default)","text":"Colors are assigned by group (column), using the Wong colorblind-friendly palette:\n\nchordplot!(ax, cooc; colorscheme = :group)","category":"section"},{"location":"user_guide/colors/#Categorical-Colors","page":"Color Schemes","title":"Categorical Colors","text":"Each label gets a distinct color:\n\nchordplot!(ax, cooc; colorscheme = :categorical)\n\n<img src=\"assets/examples/categorical.png\" alt=\"Categorical Colors\" style=\"max-width: 600px;\"/>\n\nWhat this shows: This example uses colorscheme=:categorical, which assigns a distinct color to each individual label rather than grouping by category. Compare this to the basic example where all V labels share one color, all D labels another, etc. Here, every label (V1, V2, V3, D1, D2, J1, J2) gets its own unique color from the palette. This makes it easier to distinguish individual labels at a glance, but you lose the visual grouping by category. Ribbons blend the colors of their source and target labels, creating a gradient effect that shows which specific labels are connected.","category":"section"},{"location":"user_guide/colors/#Custom-Color-Schemes","page":"Color Schemes","title":"Custom Color Schemes","text":"Create your own color scheme:\n\n# Custom group colors\ncustom_cs = GroupColorScheme(\n    Dict(\n        :V_call => RGB(0.85, 0.32, 0.32),  # Red\n        :D_call => RGB(0.32, 0.72, 0.32),  # Green\n        :J_call => RGB(0.32, 0.45, 0.85)   # Blue\n    ),\n    RGB(0.6, 0.6, 0.6)  # Default color\n)\n\nchordplot!(ax, cooc; colorscheme = custom_cs)","category":"section"},{"location":"user_guide/colors/#Color-Utilities","page":"Color Schemes","title":"Color Utilities","text":"# Modify colors\nc = RGB(0.5, 0.5, 0.5)\nc_alpha = with_alpha(c, 0.7)    # Add transparency\nc_dark = darken(c, 0.2)         # Darken by 20%\nc_light = lighten(c, 0.2)       # Lighten by 20%","category":"section"},{"location":"#ChordPlots.jl","page":"Home","title":"ChordPlots.jl","text":"<div align=\"center\">\n  <img src=\"https://github.com/user-attachments/assets/83f44cf6-e791-47e7-acbe-f36c8bfd1add\" width=\"120\" height=\"120\" alt=\"ChordPlots\" />\n  <h1>ChordPlots.jl</h1>\n  <p>A Julia package for creating beautiful chord diagrams with Makie</p>\n</div>\n\nChordPlots.jl is a Julia package for creating chord diagrams using the Makie plotting ecosystem. Chord diagrams visualize relationships between categorical variables, showing how different categories co-occur with each other.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Simple API - Create chord diagrams from DataFrames\nModern colors - Professional color schemes (Wong palette, same as AlgebraOfGraphics)\nFlexible filtering - Filter by value, top N, or minimum flow\nCustomizable - Control layout, colors, labels, and styling\nType-stable - Efficient parametric types for performance","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using CairoMakie, ChordPlots, DataFrames\n\ndf = DataFrame(\n    V = [\"V1\", \"V1\", \"V2\", \"V2\"],\n    D = [\"D1\", \"D2\", \"D1\", \"D2\"],\n    J = [\"J1\", \"J1\", \"J2\", \"J2\"]\n)\n\ncooc = cooccurrence_matrix(df, [:V, :D, :J])\n\nfig = Figure(size=(800, 800))\nax = Axis(fig[1,1])\nchordplot!(ax, cooc)\nsetup_chord_axis!(ax)\nfig","category":"section"},{"location":"#Example-Visualizations","page":"Home","title":"Example Visualizations","text":"","category":"section"},{"location":"#Basic-Chord-Diagram","page":"Home","title":"Basic Chord Diagram","text":"This is the default chord diagram with standard settings. Labels are arranged around the circle grouped by their category (V, D, J), and ribbons connect labels that co-occur. Ribbon thickness represents the co-occurrence frequency. Colors are assigned by group (each category gets a distinct color), and all ribbons use uniform opacity.\n\nKey features:\n\nDefault group-based color scheme (Wong palette)\nUniform ribbon opacity (ribbon_alpha = 0.65)\nLabels sorted by group\nStandard inner radius (inner_radius = 0.92)\n\n(Image: Basic Example)","category":"section"},{"location":"#Filtered-Data","page":"Home","title":"Filtered Data","text":"This example demonstrates data filtering using filter_top_n(), which keeps only the top 8 labels by total flow (sum of all connections). The original dataset contained many more labels (A1-A8, B1-B5, C1-C4), but filtering reduces it to only the most connected labels. This is particularly useful when working with large datasets where you want to focus on the most important relationships and reduce visual clutter from many small, weaker connections.\n\nWhat this shows:\n\nOnly top 8 labels by total flow are displayed (out of many more in the original data)\nFocuses attention on the strongest relationships\nUseful for large datasets where filtering helps identify key patterns\n\n(Image: Filtered Example)","category":"section"},{"location":"#Value-based-Opacity","page":"Home","title":"Value-based Opacity","text":"Here, ribbon opacity varies based on the co-occurrence value using ribbon_alpha_by_value=true. Thicker ribbons (higher values) appear more opaque, while thinner ribbons (lower values) are more transparent. This creates a visual hierarchy where important connections stand out more prominently.\n\nWhat's different:\n\nribbon_alpha_by_value=true enables value-based opacity scaling\nRibbons with higher co-occurrence counts are more opaque\nRibbons with lower counts are more transparent\nCreates a visual emphasis on stronger relationships\n\n(Image: Opacity Example)","category":"section"},{"location":"#Categorical-Colors","page":"Home","title":"Categorical Colors","text":"This example uses colorscheme=:categorical, which assigns a distinct color to each individual label rather than grouping by category. Every label gets its own unique color from the palette, making it easier to distinguish individual labels at the cost of losing the group-based color coding.\n\nWhat's different:\n\ncolorscheme=:categorical instead of :group\nEach label has its own distinct color\nNo color grouping by category\nUseful when you need to distinguish many individual labels\n\n(Image: Categorical Colors)","category":"section"},{"location":"#Custom-Layout","page":"Home","title":"Custom Layout","text":"What is a custom layout? A custom layout allows you to control how labels are arranged around the circle and how the arcs are sized. This example demonstrates several layout customizations: sorting by value (largest arcs first), adjusting the inner radius (how close ribbons start to the center), and changing the gap between arcs.\n\nWhat's different:\n\nsort_by=:value - Labels are sorted by their total flow (largest first), so the most connected labels get the largest arcs\ninner_radius=0.85 - Ribbons start closer to the center (default is 0.92), creating more space between ribbon endpoints and the outer circle\ngap_fraction=0.05 - Slightly larger gaps between arc segments (default is 0.03), making individual arcs more distinct\n\nThese settings help emphasize the most important labels and create a different visual balance compared to the default group-sorted layout.\n\n(Image: Custom Layout)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/mashu/ChordPlots.jl\")","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Explore the documentation to learn how to:\n\nGet started with your first chord diagram\nCreate co-occurrence data from various sources\nCustomize appearance with colors, layouts, and styling\nFilter and manage data for better visualizations\nUse advanced features for publication-quality figures","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MIT License","category":"section"},{"location":"examples/basic/#Basic-Example","page":"Basic Example","title":"Basic Example","text":"A simple example showing how to create a chord diagram.\n\nusing CairoMakie, ChordPlots, DataFrames\n\n# Create sample data\ndf = DataFrame(\n    V = [\"V1\", \"V1\", \"V2\", \"V2\", \"V3\"],\n    D = [\"D1\", \"D2\", \"D1\", \"D2\", \"D1\"],\n    J = [\"J1\", \"J1\", \"J2\", \"J2\", \"J1\"]\n)\n\n# Create co-occurrence matrix\ncooc = cooccurrence_matrix(df, [:V, :D, :J])\n\n# Create plot\nfig = Figure(size=(800, 800))\nax = Axis(fig[1,1], title=\"Basic Chord Diagram\")\nchordplot!(ax, cooc)\nsetup_chord_axis!(ax)\nfig\n\n<img src=\"assets/examples/basic.png\" alt=\"Basic Example\" style=\"max-width: 600px;\"/>\n\nWhat this shows: This is the default chord diagram with standard settings. Labels are arranged around the circle grouped by their category (V, D, J), and ribbons connect labels that co-occur. Ribbon thickness represents the co-occurrence frequency. Colors are assigned by group (each category gets a distinct color), and all ribbons use uniform opacity. This is the simplest way to visualize co-occurrence relationships.","category":"section"},{"location":"user_guide/creating_data/#Creating-Co-occurrence-Data","page":"Creating Data","title":"Creating Co-occurrence Data","text":"There are several ways to create co-occurrence data for chord diagrams.","category":"section"},{"location":"user_guide/creating_data/#From-DataFrames","page":"Creating Data","title":"From DataFrames","text":"The most common approach is to use a DataFrame where each row represents an observation:\n\ndf = DataFrame(\n    Group1 = [\"A\", \"A\", \"B\", \"B\", \"C\"],\n    Group2 = [\"X\", \"Y\", \"X\", \"Y\", \"X\"],\n    Group3 = [\"1\", \"1\", \"2\", \"2\", \"1\"]\n)\n\ncooc = cooccurrence_matrix(df, [:Group1, :Group2, :Group3])\n\nThe function automatically:\n\nExtracts unique labels from each column\nGroups labels by their source column\nCounts co-occurrences between labels from different groups\nCreates a symmetric co-occurrence matrix","category":"section"},{"location":"user_guide/creating_data/#From-Raw-Matrices","page":"Creating Data","title":"From Raw Matrices","text":"For more control, create a CoOccurrenceMatrix directly:\n\nmatrix = [10 5 2; 5 8 3; 2 3 6]\nlabels = [\"A\", \"B\", \"C\"]\ngroups = [\n    GroupInfo{String}(:Group1, [\"A\", \"B\"], 1:2),\n    GroupInfo{String}(:Group2, [\"C\"], 3:3)\n]\n\ncooc = CoOccurrenceMatrix(matrix, labels, groups)","category":"section"},{"location":"user_guide/creating_data/#Handling-Missing-Values","page":"Creating Data","title":"Handling Missing Values","text":"Missing values are automatically skipped:\n\ndf = DataFrame(\n    A = [\"a1\", missing, \"a2\"],\n    B = [\"b1\", \"b1\", missing]\n)\ncooc = cooccurrence_matrix(df, [:A, :B])  # Handles missing gracefully","category":"section"},{"location":"user_guide/creating_data/#Normalization","page":"Creating Data","title":"Normalization","text":"Convert counts to frequencies:\n\ncooc = cooccurrence_matrix(df, [:V, :D, :J]; normalize=true)\n# or\ncooc_norm = normalize(cooc)","category":"section"}]
}
