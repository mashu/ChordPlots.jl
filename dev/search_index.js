var documenterSearchIndex = {"docs":
[{"location":"user_guide/customization/#Customization","page":"Customization","title":"Customization","text":"Customize the appearance of your chord diagrams. Parameters are designed to work together: alpha controls opacity; alpha_by_value applies strength-based opacity; focus dimming affects labels, arcs, and ribbons automatically.","category":"section"},{"location":"user_guide/customization/#Layout-Parameters","page":"Customization","title":"Layout Parameters","text":"Control the overall layout:\n\nchordplot!(ax, cooc;\n    inner_radius = 0.92,    # Inner radius for ribbons\n    outer_radius = 1.0,     # Outer radius for arcs\n    arc_width = 0.08,       # Width of arc segments\n    gap_fraction = 0.03,    # Gap between arcs\n    sort_by = :group,       # :group, :value, or :none\n    arc_scale = 1.0,        # Fraction of width for arcs; < 1 adds gaps\n    ribbon_width_power = 1.0 # Exponent for ribbon thickness\n)\n\nRibbon thickness (ribbon_width_power): Ribbon widths are scaled as (value/flow)^power. Use a value greater than 1 (e.g. 1.5 or 2.0) to make strong connections visibly thicker and weak ones thinner.\n\nGaps between arcs (gap_fraction and arc_scale): gap_fraction reserves that fraction of the circle for gaps. arc_scale < 1 adds further separation.","category":"section"},{"location":"user_guide/customization/#Ribbon-Styling","page":"Customization","title":"Ribbon Styling","text":"chordplot!(ax, cooc;\n    ribbon_tension = 0.5,   # Bezier curve tension (0 = straight, 1 = tight)\n    min_ribbon_value = 0    # Hide ribbons below this value\n)","category":"section"},{"location":"user_guide/customization/#Opacity-Control","page":"Customization","title":"Opacity Control","text":"Use alpha to control opacity. It accepts:\n\nSingle value: applies to ribbons, arcs, and labels equally\nTuple (ribbons, arcs, labels): per-component control  \nComponentAlpha: named fields for clarity\n\n# All components at 70% opacity\nchordplot!(ax, cooc; alpha = 0.7)\n\n# Semi-transparent ribbons, solid arcs and labels (tuple)\nchordplot!(ax, cooc; alpha = (0.5, 1.0, 1.0))\n\n# Named fields for clarity (recommended)\nchordplot!(ax, cooc; alpha = ComponentAlpha(ribbons=0.5, arcs=1.0, labels=1.0))\n\nDefault is alpha = 1.0 (fully opaque).","category":"section"},{"location":"user_guide/customization/#Strength-based-Opacity","page":"Customization","title":"Strength-based Opacity","text":"Use alpha_by_value to scale opacity by strength. It accepts:\n\ntrue/false: simple on/off with defaults\nValueScaling: full control over which components scale\n\n# Scale all components by value\nchordplot!(ax, cooc; alpha_by_value = true)\n\n# Full control with ValueScaling\nchordplot!(ax, cooc; alpha_by_value = ValueScaling(\n    enabled = true,\n    components = (true, true, false),  # ribbons, arcs, but not labels\n    min_alpha = 0.2,\n    scale = :log\n))\n\n<img src=\"assets/examples/opacity.png\" alt=\"Strength-based Opacity\" style=\"max-width: 600px;\"/>","category":"section"},{"location":"user_guide/customization/#ValueScaling-Fields","page":"Customization","title":"ValueScaling Fields","text":"enabled::Bool: Whether scaling is active\ncomponents::NTuple{3,Bool}: Which components scale (ribbons, arcs, labels)\nmin_alpha::Float64: Minimum opacity for weakest values (default: 0.1)\nscale::Symbol: :linear or :log scaling\n\nComponents set to false remain fully opaque (alpha = 1.0).","category":"section"},{"location":"user_guide/customization/#Focus-(Dim-a-Subset-of-Labels)","page":"Customization","title":"Focus (Dim a Subset of Labels)","text":"Set focus_group and focus_labels to highlight specific labels. Non-focused labels in that group are dimmed automatically.\n\nchordplot!(ax, cooc; focus_group = :V_call, focus_labels = [\"V1\", \"V2\"])","category":"section"},{"location":"user_guide/customization/#Arc-Styling","page":"Customization","title":"Arc Styling","text":"chordplot!(ax, cooc;\n    arc_width = 0.08,\n    arc_strokewidth = 0.5,\n    arc_strokecolor = :black\n)","category":"section"},{"location":"user_guide/customization/#Label-Customization","page":"Customization","title":"Label Customization","text":"chordplot!(ax, cooc;\n    show_labels = true,\n    label_offset = 0.12,        # Distance from arc\n    label_fontsize = 10,\n    label_color = :black,       # Use :group to color by category\n    rotate_labels = true,       # Rotate to follow arc\n    label_justify = :inside     # :inside or :outside\n)\n\nTips for long labels:\n\nIncrease label_offset (e.g., 0.18) to move labels further out\nUse label_justify = :inside to align toward circle center\nAdjust label_fontsize based on figure size","category":"section"},{"location":"examples/basic/#Basic-Example","page":"Basic Example","title":"Basic Example","text":"A simple example showing how to create a chord diagram.\n\nusing CairoMakie, ChordPlots, DataFrames\n\n# Create sample data\ndf = DataFrame(\n    V = [\"V1\", \"V1\", \"V2\", \"V2\", \"V3\"],\n    D = [\"D1\", \"D2\", \"D1\", \"D2\", \"D1\"],\n    J = [\"J1\", \"J1\", \"J2\", \"J2\", \"J1\"]\n)\n\n# Create co-occurrence matrix\ncooc = cooccurrence_matrix(df, [:V, :D, :J])\n\n# Create plot\nfig = Figure(size=(800, 800))\nax = Axis(fig[1,1], title=\"Basic Chord Diagram\")\nchordplot!(ax, cooc)\nsetup_chord_axis!(ax)\nfig\n\n<img src=\"assets/examples/basic.png\" alt=\"Basic Example\" style=\"max-width: 600px;\"/>\n\nWhat this shows: This is the default chord diagram with standard settings. Labels are arranged around the circle grouped by their category (V, D, J), and ribbons connect labels that co-occur. Ribbon thickness represents the co-occurrence frequency. Colors are assigned by group (each category gets a distinct color), and all ribbons use uniform opacity. This is the simplest way to visualize co-occurrence relationships.","category":"section"},{"location":"user_guide/layout/#Layout-Configuration","page":"Layout Configuration","title":"Layout Configuration","text":"Advanced control over chord diagram layout.","category":"section"},{"location":"user_guide/layout/#Custom-Layout","page":"Layout Configuration","title":"Custom Layout","text":"Compute layouts manually for advanced control:\n\nconfig = LayoutConfig(\n    inner_radius = 0.75,    # Ribbon attachment radius\n    outer_radius = 1.0,     # Arc outer radius\n    gap_fraction = 0.05,    # Gap between arcs\n    arc_scale = 1.0,        # Fraction of width for arcs; < 1 adds gaps between arcs/labels\n    ribbon_width_power = 1.0, # Exponent for ribbon thickness; > 1 makes thick vs thin more dramatic\n    start_angle = π/2,      # Start at top (0 = right)\n    direction = 1,          # 1 = counterclockwise, -1 = clockwise\n    sort_by = :group        # :group, :value, or :none\n)\n\nlayout = compute_layout(cooc, config)\n\ngap_fraction: Fraction of the full circle reserved for gaps (e.g. 0.05 → 5% gap, 95% for arcs).\narc_scale: Scale factor for the arc (content) portion only; the rest is gap. With arc_scale = 1.0 the arcs use all of the non-gap space; with arc_scale < 1 (e.g. 0.7) arcs use less and gaps grow. So it does not conflict with gap_fraction — it adds extra separation on top of it.\nribbon_width_power: Exponent for ribbon thickness: (value/flow)^power. Use > 1 (e.g. 1.5 or 2) to make thick ribbons thicker and thin ones thinner.\n\nWhat is a custom layout? A custom layout allows you to control how labels are arranged around the circle, how arcs are sized, and the spacing between elements. This gives you fine-grained control over the visual appearance beyond the default settings.\n\n<img src=\"assets/examples/layout.png\" alt=\"Custom Layout\" style=\"max-width: 600px;\"/>\n\nWhat this shows: This example demonstrates several layout customizations applied together:\n\nsort_by=:value - Labels are sorted by their total flow (largest first), so the most connected labels get the largest arcs and appear first. Compare this to the basic example where labels are sorted by group - here, the most important labels are visually emphasized.\ninner_radius=0.85 - Ribbons start closer to the center (default is 0.92), creating more space between ribbon endpoints and the outer circle. This gives a different visual balance and can help when you have many connections.\ngap_fraction=0.05 - Slightly larger gaps between arc segments (default is 0.03), making individual arcs more distinct and easier to identify.\n\nThese settings work together to create a layout that emphasizes the most important labels and creates a different visual hierarchy compared to the default group-sorted layout.","category":"section"},{"location":"user_guide/layout/#Sorting-Options","page":"Layout Configuration","title":"Sorting Options","text":":group - Keep groups together, sort within groups by value (default)\n:value - Sort all labels by total flow (descending)\n:none - Use original order","category":"section"},{"location":"user_guide/layout/#Consistent-Ordering-Across-Multiple-Plots","page":"Layout Configuration","title":"Consistent Ordering Across Multiple Plots","text":"When comparing chord diagrams from different data sources (e.g. different samples or donors), label order should be consistent so viewers can compare positions. There are two approaches:","category":"section"},{"location":"user_guide/layout/#Approach-1:-expand_labels-(show-all-labels,-missing-ones-as-empty-arcs)","page":"Layout Configuration","title":"Approach 1: expand_labels (show all labels, missing ones as empty arcs)","text":"Use expand_labels when you want all labels to appear in both plots, even if a label only exists in one matrix. Missing labels appear as empty arcs (zero flow, no ribbons).\n\n# Two matrices with different genes\ncooc_A = cooccurrence_matrix(df_A, [:V_call, :J_call])\ncooc_B = cooccurrence_matrix(df_B, [:V_call, :J_call])\n\n# Expand to union of labels (missing labels get zero flow → empty arcs)\nexp_A, exp_B = expand_labels(cooc_A, cooc_B)\n\n# Now both have the same labels; plot with consistent positions\norder = label_order(exp_A)  # or label_order(exp_B) — same labels\nchordplot!(ax1, exp_A; label_order = order)\nchordplot!(ax2, exp_B; label_order = order)","category":"section"},{"location":"user_guide/layout/#Approach-2:-label_order-only-(each-plot-shows-only-its-own-labels)","page":"Layout Configuration","title":"Approach 2: label_order only (each plot shows only its own labels)","text":"Use label_order alone when you want each plot to show only its own labels, but with shared labels in consistent positions. Labels unique to one matrix won't appear in the other plot.\n\n# Get a unified order (union of labels, sorted by combined flow)\norder = label_order(cooc_A, cooc_B)\n\n# Plot with same positions for shared labels; unique labels only in their plot\nchordplot!(ax1, cooc_A; label_order = order)\nchordplot!(ax2, cooc_B; label_order = order)","category":"section"},{"location":"user_guide/layout/#Single-Matrix-Order-(reuse-from-one-plot)","page":"Layout Configuration","title":"Single-Matrix Order (reuse from one plot)","text":"When matrices have the same labels, simply reuse the order from one:\n\n# First plot\nfig1, ax1, plt1 = chordplot(cooc_A)\n\n# Extract and reuse its order for a comparable second plot\norder = label_order(cooc_A)\nfig2, ax2, plt2 = chordplot(cooc_B; label_order = order)","category":"section"},{"location":"user_guide/layout/#Options-for-label_order-with-Multiple-Matrices","page":"Layout Configuration","title":"Options for label_order with Multiple Matrices","text":"sort_by: :group (default), :value, or :none — how labels are sorted.\ninclude_all: If true (default), include all labels from any matrix. If false, include only labels present in all matrices (intersection).\n\n# Only labels that exist in BOTH matrices\norder_common = label_order(cooc_A, cooc_B; include_all = false)\n\n# Sort by total combined flow across both\norder_by_value = label_order(cooc_A, cooc_B; sort_by = :value)","category":"section"},{"location":"user_guide/layout/#Accessing-Layout-Data","page":"Layout Configuration","title":"Accessing Layout Data","text":"layout = compute_layout(cooc)\n\n# Get information\nnarcs(layout)      # Number of arcs\nnribbons(layout)   # Number of ribbons\n\n# Access arcs\nfor arc in layout.arcs\n    println(\"Label $(arc.label_idx): $(arc.start_angle) to $(arc.end_angle)\")\nend\n\n# Access ribbons\nfor ribbon in layout.ribbons\n    println(\"Connection: $(ribbon.source.label_idx) → $(ribbon.target.label_idx), value: $(ribbon.value)\")\nend","category":"section"},{"location":"user_guide/colors/#Color-Schemes","page":"Color Schemes","title":"Color Schemes","text":"ChordPlots uses modern, professional color palettes by default.","category":"section"},{"location":"user_guide/colors/#Group-based-Colors-(Default)","page":"Color Schemes","title":"Group-based Colors (Default)","text":"Colors are assigned by group (column), using the Wong colorblind-friendly palette:\n\nchordplot!(ax, cooc; colorscheme = :group)","category":"section"},{"location":"user_guide/colors/#Categorical-Colors","page":"Color Schemes","title":"Categorical Colors","text":"Each label gets a distinct color:\n\nchordplot!(ax, cooc; colorscheme = :categorical)\n\n<img src=\"assets/examples/categorical.png\" alt=\"Categorical Colors\" style=\"max-width: 600px;\"/>\n\nWhat this shows: This example uses colorscheme=:categorical, which assigns a distinct color to each individual label rather than grouping by category. Compare this to the basic example where all V labels share one color, all D labels another, etc. Here, every label (V1, V2, V3, D1, D2, J1, J2) gets its own unique color from the palette. This makes it easier to distinguish individual labels at a glance, but you lose the visual grouping by category. Ribbons blend the colors of their source and target labels, creating a gradient effect that shows which specific labels are connected.","category":"section"},{"location":"user_guide/colors/#Custom-Color-Schemes","page":"Color Schemes","title":"Custom Color Schemes","text":"Create your own color scheme:\n\n# Custom group colors\ncustom_cs = GroupColorScheme(\n    Dict(\n        :V_call => RGB(0.85, 0.32, 0.32),  # Red\n        :D_call => RGB(0.32, 0.72, 0.32),  # Green\n        :J_call => RGB(0.32, 0.45, 0.85)   # Blue\n    ),\n    RGB(0.6, 0.6, 0.6)  # Default color\n)\n\nchordplot!(ax, cooc; colorscheme = custom_cs)","category":"section"},{"location":"user_guide/colors/#Color-Utilities","page":"Color Schemes","title":"Color Utilities","text":"# Modify colors\nc = RGB(0.5, 0.5, 0.5)\nc_alpha = with_alpha(c, 0.7)    # Add transparency\nc_dark = darken(c, 0.2)         # Darken by 20%\nc_light = lighten(c, 0.2)       # Lighten by 20%","category":"section"},{"location":"user_guide/creating_data/#Creating-Co-occurrence-Data","page":"Creating Data","title":"Creating Co-occurrence Data","text":"There are several ways to create co-occurrence data for chord diagrams.","category":"section"},{"location":"user_guide/creating_data/#From-DataFrames","page":"Creating Data","title":"From DataFrames","text":"The most common approach is to use a DataFrame where each row represents an observation:\n\ndf = DataFrame(\n    Group1 = [\"A\", \"A\", \"B\", \"B\", \"C\"],\n    Group2 = [\"X\", \"Y\", \"X\", \"Y\", \"X\"],\n    Group3 = [\"1\", \"1\", \"2\", \"2\", \"1\"]\n)\n\ncooc = cooccurrence_matrix(df, [:Group1, :Group2, :Group3])\n\nThe function automatically:\n\nExtracts unique labels from each column\nGroups labels by their source column\nCounts co-occurrences between labels from different groups\nCreates a symmetric co-occurrence matrix","category":"section"},{"location":"user_guide/creating_data/#From-Raw-Matrices","page":"Creating Data","title":"From Raw Matrices","text":"For more control, create a CoOccurrenceMatrix directly:\n\nmatrix = [10 5 2; 5 8 3; 2 3 6]\nlabels = [\"A\", \"B\", \"C\"]\ngroups = [\n    GroupInfo{String}(:Group1, [\"A\", \"B\"], 1:2),\n    GroupInfo{String}(:Group2, [\"C\"], 3:3)\n]\n\ncooc = CoOccurrenceMatrix(matrix, labels, groups)","category":"section"},{"location":"user_guide/creating_data/#Handling-Missing-Values","page":"Creating Data","title":"Handling Missing Values","text":"Missing values are automatically skipped:\n\ndf = DataFrame(\n    A = [\"a1\", missing, \"a2\"],\n    B = [\"b1\", \"b1\", missing]\n)\ncooc = cooccurrence_matrix(df, [:A, :B])  # Handles missing gracefully","category":"section"},{"location":"user_guide/creating_data/#Normalization-and-combined-data","page":"Creating Data","title":"Normalization and combined data","text":"Convert counts to frequencies (matrix sums to 1):\n\ncooc = cooccurrence_matrix(df, [:V, :D, :J])\ncooc_norm = normalize(cooc)  # returns NormalizedCoOccurrenceMatrix\n\nTo combine multiple matrices (e.g. one per donor/sample), use mean_normalized(coocs): each matrix is normalized by its own total sum and the element-wise mean is taken. When label sets differ across matrices, they are aligned to the union of all labels (missing entries as zero). Same group structure (group names and order) is required.\n\ncoocs = [cooccurrence_matrix(df_i, cols) for df_i in list_of_dfs]\ncombined = mean_normalized(coocs)\nchordplot(combined; min_ribbon_value=0.001)\n\nBoth CoOccurrenceMatrix (counts) and NormalizedCoOccurrenceMatrix (frequencies) work with chordplot, compute_layout, and the rest of the API.","category":"section"},{"location":"user_guide/basic_plotting/#Basic-Plotting","page":"Basic Plotting","title":"Basic Plotting","text":"Learn how to create and customize chord diagrams.","category":"section"},{"location":"user_guide/basic_plotting/#Simple-Plot","page":"Basic Plotting","title":"Simple Plot","text":"fig = Figure(size=(800, 800))\nax = Axis(fig[1,1], title=\"My Chord Diagram\")\nchordplot!(ax, cooc)\nsetup_chord_axis!(ax)\nfig\n\n<img src=\"assets/examples/basic.png\" alt=\"Basic Plot\" style=\"max-width: 600px;\"/>","category":"section"},{"location":"user_guide/basic_plotting/#Standalone-Plot","page":"Basic Plotting","title":"Standalone Plot","text":"You can also create a plot without explicitly creating an axis:\n\nfig, ax, plt = chordplot(cooc)\nsetup_chord_axis!(ax)\nfig","category":"section"},{"location":"user_guide/basic_plotting/#Essential-Setup","page":"Basic Plotting","title":"Essential Setup","text":"Always call setup_chord_axis! after plotting to:\n\nSet equal aspect ratio\nRemove axis decorations\nSet appropriate limits\n\nsetup_chord_axis!(ax; padding=0.2)  # padding controls margin around plot","category":"section"},{"location":"user_guide/basic_plotting/#Plotting-from-DataFrame","page":"Basic Plotting","title":"Plotting from DataFrame","text":"You can plot directly from a DataFrame:\n\nchordplot!(ax, df, [:V, :D, :J])\n\nThis is equivalent to:\n\ncooc = cooccurrence_matrix(df, [:V, :D, :J])\nchordplot!(ax, cooc)","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete reference for all exported functions and types.","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Data-Types","page":"API Reference","title":"Data Types","text":"","category":"section"},{"location":"api/#Data-Management","page":"API Reference","title":"Data Management","text":"","category":"section"},{"location":"api/#Comparison","page":"API Reference","title":"Comparison","text":"","category":"section"},{"location":"api/#Data-Exploration","page":"API Reference","title":"Data Exploration","text":"Inspect the distribution of co-occurrence values to choose thresholds (e.g. min_ribbon_value, filter_by_threshold):","category":"section"},{"location":"api/#Layout-Functions","page":"API Reference","title":"Layout Functions","text":"","category":"section"},{"location":"api/#Opacity-Configuration","page":"API Reference","title":"Opacity Configuration","text":"","category":"section"},{"location":"api/#Color-Functions","page":"API Reference","title":"Color Functions","text":"categorical_colors(n::Int; palette=:default) - Create n distinguishable colors using Makie's default categorical palette (same as AlgebraOfGraphics uses - Wong colors, colorblind-friendly).","category":"section"},{"location":"api/#Geometry-Functions","page":"API Reference","title":"Geometry Functions","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"These functions are exported but don't have separate docstrings:\n\nnlabels(cooc) - Number of labels in co-occurrence matrix\nngroups(cooc) - Number of groups  \ntotal_flow(cooc, label_idx) - Total flow for a label (sum of all connections)\nget_group(cooc, label_idx) - Get group symbol for a label\nnarcs(layout) - Number of arcs in layout\nnribbons(layout) - Number of ribbons in layout\narc_span(arc) - Span angle of an arc\narc_midpoint(arc) - Midpoint angle of an arc\nendpoint_span(endpoint) - Span of a ribbon endpoint\nendpoint_midpoint(endpoint) - Midpoint of a ribbon endpoint\nis_self_loop(ribbon) - Check if ribbon is a self-loop\nresolve_arc_color(scheme, arc, cooc) - Resolve color for an arc\nresolve_ribbon_color(scheme, ribbon, cooc) - Resolve color for a ribbon\nchordplot!(ax, cooc; kwargs...) - In-place version of chordplot","category":"section"},{"location":"api/#ChordPlots.cooccurrence_matrix","page":"API Reference","title":"ChordPlots.cooccurrence_matrix","text":"cooccurrence_matrix(df::DataFrame, columns::Vector{Symbol}; normalize=false)\n\nCompute a co-occurrence matrix from a DataFrame.\n\nEach row in the DataFrame represents one observation. Labels from different columns that appear in the same row are considered co-occurring.\n\nArguments\n\ndf::DataFrame: Input data\ncolumns::Vector{Symbol}: Column names to analyze\n\nKeywords\n\nnormalize::Bool=false: If true, normalize counts so matrix sums to 1 (frequencies)\n\nReturns\n\nCoOccurrenceMatrix: Matrix of co-occurrence counts or frequencies\n\nNote on normalized / combined data\n\nThe matrix can hold raw counts or proportions. To combine multiple donors/samples, normalize each by its own total sum then take the element-wise mean — use mean_normalized. Layout uses only relative magnitudes; set min_ribbon_value and min_arc_flow to match your scale (e.g. small for proportions).\n\nExample\n\ndf = DataFrame(\n    V_call = [\"IGHV1-2*01\", \"IGHV1-2*01\", \"IGHV3-23*01\"],\n    D_call = [\"IGHD2-2*01\", \"IGHD3-10*01\", \"IGHD2-2*01\"],\n    J_call = [\"IGHJ6*01\", \"IGHJ6*01\", \"IGHJ4*02\"]\n)\ncooc = cooccurrence_matrix(df, [:V_call, :D_call, :J_call])\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.chordplot","page":"API Reference","title":"ChordPlots.chordplot","text":"chordplot(cooc::AbstractChordData)\nchordplot!(ax, cooc::AbstractChordData)\n\nCreate a chord diagram from co-occurrence data.\n\nAttributes (grouped by purpose)\n\nRadii and arc size\n\ninner_radius = 0.92: Inner radius for ribbons\nouter_radius = 1.0: Outer radius for arcs\narc_width = 0.08: Width of arc segments\n\nArc and gap layout\n\ngap_fraction = 0.03: Fraction of circle reserved for gaps\narc_scale = 1.0: Scale for arc portion; < 1 adds extra gaps\nsort_by = :group: Order arcs by :group, :value, or :none\nlabel_order = nothing: Fixed order (overrides sort_by)\n\nRibbon appearance\n\nribbon_width_power = 1.0: Exponent for ribbon width\nmin_ribbon_value = 0: Hide ribbons below this value\nribbon_tension = 0.5: Bezier curve tension\n\nArc appearance\n\narc_strokewidth = 0.5: Border width\narc_strokecolor = :black: Border color\n\nLabels\n\nshow_labels = true: Whether to show labels\nlabel_offset = 0.12: Distance from arc to label\nlabel_fontsize = 10: Font size\nlabel_color = :black: Color (use :group for category colors)\nrotate_labels = true: Rotate labels to follow arcs\nlabel_justify = :inside: :inside or :outside\nmin_arc_flow = 0: Hide arcs below this flow\n\nColors\n\ncolorscheme = :group: Color scheme (:group, :categorical, or AbstractColorScheme)\n\nOpacity\n\nalpha = 1.0: Opacity for components. Accepts:\nReal: Same value for all (e.g., alpha=0.7)\nTuple: Per-component (ribbons, arcs, labels) \nComponentAlpha: Named fields for clarity\n\nValue-based opacity scaling\n\nalpha_by_value = false: Scale opacity by value. Accepts Bool or ValueScaling\n\nWhen alpha_by_value=true (or a ValueScaling):\n\nRibbons scale by co-occurrence value\nArcs/labels scale by total flow\nComponents excluded from scaling stay fully opaque\n\nFocus (highlight subset)\n\nfocus_group = nothing: Group to apply focus styling\nfocus_labels = nothing: Labels to keep highlighted\ndim_color = RGB(0.55, 0.55, 0.55): Color for dimmed elements\ndim_alpha = 0.25: Alpha for dimmed elements\n\nExample\n\nusing CairoMakie, ChordPlots, DataFrames\n\ndf = DataFrame(\n    V_call = [\"V1\", \"V1\", \"V2\", \"V2\", \"V3\"],\n    D_call = [\"D1\", \"D2\", \"D1\", \"D2\", \"D1\"],\n    J_call = [\"J1\", \"J1\", \"J2\", \"J2\", \"J1\"]\n)\ncooc = cooccurrence_matrix(df, [:V_call, :D_call, :J_call])\n\n# Basic plot\nfig, ax, plt = chordplot(cooc)\n\n# Per-component opacity\nchordplot(cooc; alpha=ComponentAlpha(ribbons=0.5, arcs=1.0, labels=1.0))\n\n# Value-based scaling (ribbons and arcs only)\nchordplot(cooc; alpha_by_value=ValueScaling(\n    enabled=true,\n    components=(true, true, false)\n))\n\n\n\n\n\nchordplot(df::DataFrame, columns; kwargs...)\n\nCreate chord plot directly from DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.setup_chord_axis!","page":"API Reference","title":"ChordPlots.setup_chord_axis!","text":"setup_chord_axis!(ax::Axis; outer_radius=1.0, label_offset=0.12, padding=0.2)\n\nConfigure axis for chord plot display (equal aspect, no decorations). Sets axis limits so that the circle and labels fit: limits extend to outer_radius + label_offset + padding. Use the same outer_radius and label_offset as in your chordplot! call so that large label offsets don't get clipped and the title doesn't overlap the labels.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.compute_layout","page":"API Reference","title":"ChordPlots.compute_layout","text":"compute_layout(cooc::AbstractChordData, config::LayoutConfig=LayoutConfig())\n\nCompute the complete layout for a chord diagram.\n\nAlgorithm\n\nCalculate total flow for each label\nAllocate angular width proportional to flow\nAssign arc positions\nGenerate ribbon endpoints based on co-occurrence values\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.AbstractChordData","page":"API Reference","title":"ChordPlots.AbstractChordData","text":"AbstractChordData\n\nAbstract supertype for chord data (co-occurrence or normalized/frequency).\n\nAll subtypes must have fields: matrix, labels, groups, label_to_index. Use CoOccurrenceMatrix for raw counts; use NormalizedCoOccurrenceMatrix for frequencies or combined data (e.g. mean of normalized matrices from multiple sources).\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.CoOccurrenceMatrix","page":"API Reference","title":"ChordPlots.CoOccurrenceMatrix","text":"CoOccurrenceMatrix{T<:Real, S<:AbstractString}\n\nStores co-occurrence counts between labels with group information.\n\nType Parameters\n\nT: Numeric type for counts (enables Integer or Float)\nS: String type for labels\n\nFields\n\nmatrix::Matrix{T}: Symmetric co-occurrence matrix (counts, frequencies, or e.g. mean normalized counts)\nlabels::Vector{S}: Combined list of all labels\ngroups::Vector{GroupInfo{S}}: Group information\nlabel_to_index::Dict{S, Int}: Fast label lookup\n\nExample\n\ncooc = CoOccurrenceMatrix(df, [:V_call, :D_call, :J_call])\ncooc[\"IGHV1-2*01\", \"IGHD2-2*01\"]  # Get co-occurrence count\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.NormalizedCoOccurrenceMatrix","page":"API Reference","title":"ChordPlots.NormalizedCoOccurrenceMatrix","text":"NormalizedCoOccurrenceMatrix{T<:Real, S<:AbstractString} <: AbstractChordData\n\nCo-occurrence data in frequency form (matrix typically sums to 1) or combined from multiple sources (e.g. mean of per-sample normalized matrices).\n\nSame structure as CoOccurrenceMatrix; the type signals that values are on a 0–1 scale so e.g. min_ribbon_value / min_arc_flow can use small thresholds. Layout and plotting use the same logic (scale-invariant).\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.filter_top_n","page":"API Reference","title":"ChordPlots.filter_top_n","text":"filter_top_n(cooc::AbstractChordData, n::Int)\n\nKeep only the top n labels by total flow. Returns the same type as cooc.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.filter_by_threshold","page":"API Reference","title":"ChordPlots.filter_by_threshold","text":"filter_by_threshold(cooc::AbstractChordData, min_value)\n\nCreate a new matrix with values below threshold set to zero. Returns the same type as cooc.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.normalize","page":"API Reference","title":"ChordPlots.normalize","text":"normalize(cooc::CoOccurrenceMatrix) -> NormalizedCoOccurrenceMatrix\n\nReturn a normalized version where all values sum to 1. Use for comparing matrices from different sample sizes or before combining multiple sources.\n\n\n\n\n\nnormalize(cooc::NormalizedCoOccurrenceMatrix)\n\nReturn copy unchanged (already normalized).\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.mean_normalized","page":"API Reference","title":"ChordPlots.mean_normalized","text":"mean_normalized(coocs::AbstractVector{<:AbstractChordData}) -> NormalizedCoOccurrenceMatrix\n\nCombine multiple co-occurrence matrices by normalizing each by its own total sum and taking the element-wise mean. Result sums to 1. Matrices may have different labels; they are aligned to the union of all labels (per group), missing entries as zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.expand_labels","page":"API Reference","title":"ChordPlots.expand_labels","text":"expand_labels(coocs::AbstractVector{<:AbstractChordData}) -> Vector{AbstractChordData}\n\nExpand all matrices to a common label set (union of all labels per group). Labels not present in a matrix get zero flow/connections. Use this when you want to plot multiple matrices with the same labels appearing in the same positions, even if some matrices are missing certain labels.\n\nReturns matrices of the same type as input (CoOccurrenceMatrix or NormalizedCoOccurrenceMatrix).\n\nExample\n\n# Two matrices with different genes\ncooc_A = cooccurrence_matrix(df_A, [:V_call, :J_call])\ncooc_B = cooccurrence_matrix(df_B, [:V_call, :J_call])\n\n# Expand to union of labels (missing labels get zero flow → empty arcs)\nexpanded_A, expanded_B = expand_labels([cooc_A, cooc_B])\n\n# Now both have the same labels; plot with consistent positions\norder = label_order(expanded_A)  # or label_order(expanded_B) — same labels\nchordplot!(ax1, expanded_A; label_order = order)\nchordplot!(ax2, expanded_B; label_order = order)\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.diff","page":"API Reference","title":"Base.diff","text":"diff(a::AbstractChordData, b::AbstractChordData; absolute=false) -> NormalizedCoOccurrenceMatrix\n\nCompute the difference between two co-occurrence matrices: a - b. Both matrices are first normalized (so differences are in frequency space), then aligned to a common label set. Use this to visualize what changed between two conditions.\n\nKeywords\n\nabsolute::Bool = false: If true, return absolute differences |a - b| (all positive,  thickest ribbons = biggest changes). If false (default), return signed differences  (positive where a > b, negative where a < b) — use with diverging_colors  or diff_colors to show increases (red) vs decreases (blue).\n\nReturns\n\nA NormalizedCoOccurrenceMatrix with the differences. Note: the result does not sum  to 1 (it's a difference map, not a probability distribution).\n\nExample\n\n# Gene knockout experiment: what connections changed?\ncooc_wt = cooccurrence_matrix(df_wildtype, [:V_call, :J_call])\ncooc_ko = cooccurrence_matrix(df_knockout, [:V_call, :J_call])\n\n# Signed differences with diverging colormap (blue = decrease, red = increase)\nd = diff(cooc_ko, cooc_wt)  # ko - wt: positive means KO has more\nchordplot(d; colorscheme=diff_colors(d))\n\n# Or absolute differences (just magnitude of change)\nd_abs = diff(cooc_ko, cooc_wt; absolute=true)\nchordplot(d_abs; colorscheme=:Reds)\n\nSee also: normalize, expand_labels, diverging_colors, diff_colors\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.cooccurrence_values","page":"API Reference","title":"ChordPlots.cooccurrence_values","text":"cooccurrence_values(cooc::AbstractChordData) -> Vector{Float64}\n\nReturn the upper-triangle co-occurrence values (each pair counted once). Use with histogram(cooccurrence_values(cooc)) to inspect the distribution and choose min_ribbon_value.\n\n\n\n\n\ncooccurrence_values(coocs::AbstractVector{<:AbstractChordData}) -> Vector{Float64}\n\nConcatenate co-occurrence values from all matrices. Use to plot the combined distribution when choosing a threshold across multiple donors/samples.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.value_histogram","page":"API Reference","title":"ChordPlots.value_histogram","text":"value_histogram(data; kwargs...)\n\nCreate a figure with a histogram of co-occurrence values. data can be a single AbstractChordData or an abstract container of them. Returns (fig, ax, hist). Use to choose min_ribbon_value from the distribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.value_histogram!","page":"API Reference","title":"ChordPlots.value_histogram!","text":"value_histogram!(ax, data; kwargs...)\n\nPlot histogram of co-occurrence values on the given axis. data can be a single AbstractChordData or an abstract container of them (e.g. Vector of matrices). Use to inspect the distribution and choose a threshold (e.g. min_ribbon_value). Keyword arguments are passed to histogram!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.filter_ribbons","page":"API Reference","title":"ChordPlots.filter_ribbons","text":"filter_ribbons(layout::ChordLayout, min_value::Real)\n\nFilter ribbons below a minimum value threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.filter_ribbons_top_n","page":"API Reference","title":"ChordPlots.filter_ribbons_top_n","text":"filter_ribbons_top_n(layout::ChordLayout, n::Int)\n\nKeep only the top n ribbons by value.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.label_order","page":"API Reference","title":"ChordPlots.label_order","text":"label_order(cooc::AbstractChordData; sort_by=:group, label_order=nothing)\n\nReturn the label names in the order they appear around the circle for the given co-occurrence matrix and layout options. Use this to reuse the same order when creating a second chord plot for comparison.\n\nArguments\n\ncooc: Co-occurrence matrix (from the plot whose order you want to copy).\nsort_by: Same as in chordplot (:group, :value, or :none). Must match the plot you are copying from.\nlabel_order: If the first plot used a custom order, pass the same here (vector of indices or label names).\n\nReturns\n\nVector of label names in circle order (same element type as cooc.labels).\n\nExample\n\n# First plot (default sort_by=:group)\nfig1, ax1, plt1 = chordplot(cooc_A)\nsetup_chord_axis!(ax1)\n\n# Get order from cooc_A and apply to cooc_B for comparable layout\norder = label_order(cooc_A)\nfig2, ax2, plt2 = chordplot(cooc_B; label_order = order)\nsetup_chord_axis!(ax2)\n\n\n\n\n\nlabel_order(coocs::AbstractVector{<:AbstractChordData}; sort_by=:group, include_all=true)\n\nCompute a unified label order from multiple co-occurrence matrices with potentially different label sets. Returns a Vector{String} of labels suitable for chordplot(...; label_order=...) to ensure consistent label positioning across plots.\n\nArguments\n\ncoocs: Vector of co-occurrence matrices (may have different labels).\n\nKeywords\n\nsort_by::Symbol = :group: Sorting method (:group keeps groups together sorted by flow, :value sorts all by flow, :none uses union order).\ninclude_all::Bool = true: If true, include all labels from the union (labels missing in some matrices contribute zero flow). If false, include only labels present in all matrices.\n\nReturns\n\nVector{String} of label names in order.\n\nExample\n\n# Two matrices with overlapping but different genes\ncooc_A = cooccurrence_matrix(df_A, [:V_call, :J_call])\ncooc_B = cooccurrence_matrix(df_B, [:V_call, :J_call])\n\n# Get a combined order that works for both\norder = label_order([cooc_A, cooc_B])\n\n# Plot with same label positions\nchordplot!(ax1, cooc_A; label_order = order)\nchordplot!(ax2, cooc_B; label_order = order)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.LayoutConfig","page":"API Reference","title":"ChordPlots.LayoutConfig","text":"LayoutConfig{T<:Real}\n\nConfiguration for layout computation. Parameters are grouped below; they work together and are non-conflicting.\n\nFields (grouped)\n\nRadii\n\ninner_radius::T: Inner radius for ribbon attachment\nouter_radius::T: Outer radius for arcs\n\nArc and gap layout (angle allocation)\n\ngap_fraction::T: Fraction of the full circle (2π) reserved for gaps between arcs (baseline)\narc_scale::T: Scale for the arc (content) portion only. Content = (1 - gapfraction)*arcscale of 2π; rest is gap. Use < 1 for extra separation.\n\nOrientation\n\nstart_angle::T: Starting angle (0 = right, π/2 = top)\ndirection::Int: 1 = counterclockwise, -1 = clockwise\n\nOrder\n\nsort_by::Symbol: How to order arcs (:group, :value, :none). Ignored when label_order is set.\nlabel_order::Union{Nothing, Vector{Int}}: If set, fixed order of label indices on the circle (overrides sort_by)\n\nRibbon thickness\n\nribbon_width_power::T: Exponent for ribbon width (value/flow)^power; > 1 makes thick vs thin more dramatic\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.ChordLayout","page":"API Reference","title":"ChordPlots.ChordLayout","text":"ChordLayout{T<:Real}\n\nComplete layout information for rendering a chord diagram.\n\nFields\n\narcs::Vector{ArcSegment{T}}: Arc segments for each label\nribbons::Vector{Ribbon{T}}: All ribbons\ninner_radius::T: Inner radius for ribbons\nouter_radius::T: Outer radius for arcs\ngap_angle::T: Gap between adjacent arcs\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.ComponentAlpha","page":"API Reference","title":"ChordPlots.ComponentAlpha","text":"ComponentAlpha\n\nNamed opacity settings for chord diagram components. All values are clamped to [0, 1].\n\nFields\n\nribbons::Float64: Opacity for ribbons (connections)\narcs::Float64: Opacity for arcs (outer segments)\nlabels::Float64: Opacity for labels\n\nConstructors\n\nComponentAlpha(ribbons, arcs, labels): Set each component separately\nComponentAlpha(v): Set all components to the same value\nComponentAlpha((r, a, l)): Construct from a tuple\n\nExample\n\n# All components at 70% opacity\nchordplot(cooc; alpha=ComponentAlpha(0.7))\n\n# Semi-transparent ribbons, solid arcs and labels\nchordplot(cooc; alpha=ComponentAlpha(0.5, 1.0, 1.0))\n\n# Using named arguments for clarity\nchordplot(cooc; alpha=ComponentAlpha(ribbons=0.5, arcs=1.0, labels=1.0))\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.ValueScaling","page":"API Reference","title":"ChordPlots.ValueScaling","text":"ValueScaling\n\nConfiguration for value-based opacity scaling. When enabled, component opacity scales from min_alpha (weakest) to the component's base alpha (strongest).\n\nFields\n\nenabled::Bool: Whether scaling is active\nribbons::Bool: Scale ribbon opacity by co-occurrence value\narcs::Bool: Scale arc opacity by total flow\nlabels::Bool: Scale label opacity by total flow\nmin_alpha::Float64: Minimum opacity for weakest values\nscale::Symbol: :linear or :log scaling\n\nConstructors\n\nValueScaling(; enabled, components, min_alpha, scale): Full control\nValueScaling(enabled::Bool): Quick on/off with defaults\n\nExample\n\n# Scale all components by value\nchordplot(cooc; alpha_by_value=ValueScaling(enabled=true))\n\n# Scale ribbons and arcs, keep labels solid\nchordplot(cooc; alpha_by_value=ValueScaling(\n    enabled=true, \n    components=(true, true, false),\n    min_alpha=0.2\n))\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.group_colors","page":"API Reference","title":"ChordPlots.group_colors","text":"group_colors(cooc::AbstractChordData; palette=:default)\n\nCreate a color scheme based on groups using Makie's default categorical palette (same as AlgebraOfGraphics uses - Wong colors, colorblind-friendly).\n\nArguments\n\npalette::Symbol: Color palette style (:default for Makie/AoG palette, :modern for custom)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.gradient_colors","page":"API Reference","title":"ChordPlots.gradient_colors","text":"gradient_colors(; colormap=:viridis, min_val=0.0, max_val=1.0)\n\nCreate a gradient-based color scheme.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.diverging_colors","page":"API Reference","title":"ChordPlots.diverging_colors","text":"diverging_colors(cooc::AbstractChordData; negative=:steelblue, neutral=:white, positive=:firebrick, symmetric=true)\n\nCreate a diverging color scheme for signed values (e.g., from diff()).\n\nBoth ribbons and arcs are colored by their signed values:\n\nRibbons: colored by the connection's difference value\nArcs: colored by net flow (sum of all differences for that label), showing overall enrichment (positive → red) vs depletion (negative → blue)\n\nUse with diff(a, b; absolute=false) to visualize increases vs decreases.\n\nArguments\n\ncooc: The chord data (used to determine value range)\nnegative: Color for negative values/depletion (default: steel blue)\nneutral: Color for zero (default: near-white)\npositive: Color for positive values/enrichment (default: firebrick red)\nsymmetric: If true (default), range is symmetric around zero\n\nExample\n\nd = diff(cooc_after, cooc_before; absolute=false)  # positive = increase\nfig, ax, plt = chordplot(d; colorscheme=diverging_colors(d))\n# Blue arcs = labels with overall decreased connections\n# Red arcs = labels with overall increased connections\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.diff_colors","page":"API Reference","title":"ChordPlots.diff_colors","text":"diff_colors(cooc::AbstractChordData; kwargs...)\n\nAlias for diverging_colors - creates a color scheme for difference matrices.\n\nExample\n\nd = diff(cooc_after, cooc_before; absolute=false)\nchordplot(d; colorscheme=diff_colors(d))\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.with_alpha","page":"API Reference","title":"ChordPlots.with_alpha","text":"with_alpha(color::Colorant, alpha::Real)\n\nReturn color with specified alpha value.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.darken","page":"API Reference","title":"ChordPlots.darken","text":"darken(color::Colorant, factor::Real=0.2)\n\nDarken a color by the given factor.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.lighten","page":"API Reference","title":"ChordPlots.lighten","text":"lighten(color::Colorant, factor::Real=0.2)\n\nLighten a color by the given factor.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.GroupColorScheme","page":"API Reference","title":"ChordPlots.GroupColorScheme","text":"GroupColorScheme{C<:Colorant}\n\nAssigns colors based on label groups.\n\nFields\n\ngroup_colors::Dict{Symbol, C}: Color for each group\ndefault_color::C: Fallback color\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.CategoricalColorScheme","page":"API Reference","title":"ChordPlots.CategoricalColorScheme","text":"CategoricalColorScheme{C<:Colorant}\n\nAssigns distinct colors to each label.\n\nFields\n\ncolors::Vector{C}: Color palette\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.GradientColorScheme","page":"API Reference","title":"ChordPlots.GradientColorScheme","text":"GradientColorScheme\n\nColors based on a gradient (e.g., by value).\n\nFields\n\ncolormap::Symbol: Makie colormap name\nrange::Tuple{Float64, Float64}: Value range for mapping\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.DivergingColorScheme","page":"API Reference","title":"ChordPlots.DivergingColorScheme","text":"DivergingColorScheme{C<:Colorant}\n\nColor scheme for signed values (e.g., differences) using a diverging colormap. Maps negative values to one color, zero to neutral, positive to another color.\n\nBoth ribbons and arcs are colored by their signed values:\n\nRibbons: colored by the connection's difference value\nArcs: colored by net flow (sum of all differences for that label), showing  overall enrichment (positive/red) vs depletion (negative/blue)\n\nFields\n\nnegative_color::C: Color for negative values (depletion)\nneutral_color::C: Color for zero/neutral values  \npositive_color::C: Color for positive values (enrichment)\nrange::Tuple{Float64, Float64}: (min, max) value range for normalization\nsymmetric::Bool: If true, range is symmetric around zero (max absolute value)\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.arc_points","page":"API Reference","title":"ChordPlots.arc_points","text":"arc_points(start_angle::Real, end_angle::Real, radius::Real; n_points::Int=50)\n\nGenerate points along an arc.\n\nArguments\n\nstart_angle: Start angle in radians\nend_angle: End angle in radians\nradius: Arc radius\nn_points: Number of points (more = smoother)\n\nReturns\n\nVector{Point2f}: Points along the arc\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.arc_polygon","page":"API Reference","title":"ChordPlots.arc_polygon","text":"arc_polygon(inner_radius::Real, outer_radius::Real, start_angle::Real, end_angle::Real; n_points::Int=30)\n\nGenerate a filled arc (annular sector) as a polygon.\n\nReturns points forming a closed polygon: outer arc → inner arc (reversed) → close.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.ribbon_path","page":"API Reference","title":"ChordPlots.ribbon_path","text":"ribbon_path(ribbon::Ribbon, radius::Real; n_bezier::Int=30, tension::Real=0.5)\n\nGenerate the path for a ribbon connecting two arcs.\n\nThe ribbon consists of:\n\nSource arc segment\nBezier curve to target\nTarget arc segment  \nBezier curve back to source\n\nArguments\n\nribbon: Ribbon geometry specification\nradius: Radius where ribbons attach\nn_bezier: Points per Bezier curve\ntension: Control point tension (0 = straight, 1 = tight curves)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.ribbon_paths","page":"API Reference","title":"ChordPlots.ribbon_paths","text":"ribbon_paths(ribbons::Vector{Ribbon{T}}, radius::Real; kwargs...)\n\nGenerate paths for multiple ribbons.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.label_position","page":"API Reference","title":"ChordPlots.label_position","text":"label_position(arc::ArcSegment, radius::Real, offset::Real; rotate::Bool=true, justify::Symbol=:inside)\n\nCalculate position for an arc's label.\n\nArguments\n\narc: Arc segment\nradius: Outer radius of the arc\noffset: Distance from arc to label\nrotate: Whether to rotate label to follow arc\njustify: Label justification (:inside aligns toward circle center, :outside aligns away)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.label_positions","page":"API Reference","title":"ChordPlots.label_positions","text":"label_positions(arcs::Vector{ArcSegment{T}}, radius::Real, offset::Real; kwargs...)\n\nCalculate positions for all arc labels.\n\nKeyword Arguments\n\nrotate::Bool=true: Whether to rotate labels to follow arcs\njustify::Symbol=:inside: Label justification (:inside or :outside)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChordPlots.ArcSegment","page":"API Reference","title":"ChordPlots.ArcSegment","text":"ArcSegment{T<:Real}\n\nRepresents an arc on the outer circle for a single label.\n\nFields\n\nlabel_idx::Int: Index into the label array\nstart_angle::T: Starting angle in radians\nend_angle::T: Ending angle in radians  \nvalue::T: Total flow value (determines arc width)\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.RibbonEndpoint","page":"API Reference","title":"ChordPlots.RibbonEndpoint","text":"RibbonEndpoint{T<:Real}\n\nRepresents one end of a ribbon attached to an arc.\n\nFields\n\nlabel_idx::Int: Which label this endpoint is on\nstart_angle::T: Start angle on the arc\nend_angle::T: End angle on the arc\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.Ribbon","page":"API Reference","title":"ChordPlots.Ribbon","text":"Ribbon{T<:Real}\n\nRepresents a ribbon connecting two labels.\n\nFields\n\nsource::RibbonEndpoint{T}: Source endpoint\ntarget::RibbonEndpoint{T}: Target endpoint\nvalue::T: Co-occurrence value\n\n\n\n\n\n","category":"type"},{"location":"api/#ChordPlots.GroupInfo","page":"API Reference","title":"ChordPlots.GroupInfo","text":"GroupInfo{S<:AbstractString}\n\nInformation about a group of labels (e.g., V calls, D calls, J calls).\n\nFields\n\nname::Symbol: Group identifier\nlabels::Vector{S}: Labels belonging to this group\nindices::UnitRange{Int}: Index range in the combined label list\n\n\n\n\n\n","category":"type"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide will help you create your first chord diagram with ChordPlots.jl.","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/mashu/ChordPlots.jl\")","category":"section"},{"location":"getting_started/#Your-First-Chord-Diagram","page":"Getting Started","title":"Your First Chord Diagram","text":"using CairoMakie, ChordPlots, DataFrames\n\n# Create sample data\ndf = DataFrame(\n    V = [\"V1\", \"V1\", \"V2\", \"V2\"],\n    D = [\"D1\", \"D2\", \"D1\", \"D2\"],\n    J = [\"J1\", \"J1\", \"J2\", \"J2\"]\n)\n\n# Create co-occurrence matrix\ncooc = cooccurrence_matrix(df, [:V, :D, :J])\n\n# Create plot\nfig = Figure(size=(800, 800))\nax = Axis(fig[1,1], title=\"My First Chord Diagram\")\nchordplot!(ax, cooc)\nsetup_chord_axis!(ax)\nfig\n\n<img src=\"assets/examples/basic.png\" alt=\"Basic Chord Diagram\" style=\"max-width: 600px;\"/>\n\nWhat you see: This basic chord diagram shows the default visualization. Labels (V1, V2, V3, D1, D2, J1, J2) are arranged around the circle, grouped by their category. The colored arcs represent each label, and the curved ribbons connect labels that appear together in the data. Ribbon thickness indicates how frequently labels co-occur. Colors are assigned by group (all V labels share one color, all D labels another, etc.), using the default Wong color palette for a professional, colorblind-friendly appearance.","category":"section"},{"location":"getting_started/#What-Happens-Here?","page":"Getting Started","title":"What Happens Here?","text":"Data Preparation: Each row in the DataFrame represents one observation with multiple categorical variables\nCo-occurrence Matrix: cooccurrence_matrix counts how often labels from different groups appear together\nPlotting: chordplot! creates the visual representation\nSetup: setup_chord_axis! configures the axis for optimal display","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Learn about creating co-occurrence data\nExplore customization options\nSee example visualizations","category":"section"},{"location":"#ChordPlots.jl","page":"Home","title":"ChordPlots.jl","text":"<div align=\"center\">\n  <img src=\"https://github.com/user-attachments/assets/83f44cf6-e791-47e7-acbe-f36c8bfd1add\" width=\"120\" height=\"120\" alt=\"ChordPlots\" />\n  <h1>ChordPlots.jl</h1>\n  <p>A Julia package for creating beautiful chord diagrams with Makie</p>\n</div>\n\nChordPlots.jl is a Julia package for creating chord diagrams using the Makie plotting ecosystem. Chord diagrams visualize relationships between categorical variables, showing how different categories co-occur with each other.\n\nChord plots accept two kinds of input data: co-occurrence counts (CoOccurrenceMatrix, e.g. from cooccurrence_matrix(df, cols)) or normalized/frequency data (NormalizedCoOccurrenceMatrix), e.g. when combining multiple donors by normalizing each matrix by its own total sum and taking the element-wise mean (mean_normalized). Both types work with chordplot and the rest of the API.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Simple API - Create chord diagrams from DataFrames\nModern colors - Professional color schemes (Wong palette, same as AlgebraOfGraphics)\nFlexible filtering - Filter by value, top N, or minimum flow\nCustomizable - Control layout, colors, labels, and styling\nType-stable - Efficient parametric types for performance","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using CairoMakie, ChordPlots, DataFrames\n\ndf = DataFrame(\n    V = [\"V1\", \"V1\", \"V2\", \"V2\"],\n    D = [\"D1\", \"D2\", \"D1\", \"D2\"],\n    J = [\"J1\", \"J1\", \"J2\", \"J2\"]\n)\n\ncooc = cooccurrence_matrix(df, [:V, :D, :J])\n\nfig = Figure(size=(800, 800))\nax = Axis(fig[1,1])\nchordplot!(ax, cooc)\nsetup_chord_axis!(ax)\nfig","category":"section"},{"location":"#Example-Visualizations","page":"Home","title":"Example Visualizations","text":"","category":"section"},{"location":"#Basic-Chord-Diagram","page":"Home","title":"Basic Chord Diagram","text":"This is the default chord diagram with standard settings. Labels are arranged around the circle grouped by their category (V, D, J), and ribbons connect labels that co-occur. Ribbon thickness represents the co-occurrence frequency. Colors are assigned by group (each category gets a distinct color), and all ribbons use uniform opacity.\n\nKey features:\n\nDefault group-based color scheme (Wong palette)\nFully opaque by default (alpha = 1.0)\nLabels sorted by group\nStandard inner radius (inner_radius = 0.92)\n\n(Image: Basic Example)","category":"section"},{"location":"#Filtered-Data","page":"Home","title":"Filtered Data","text":"This example demonstrates data filtering using filter_top_n(), which keeps only the top 8 labels by total flow (sum of all connections). The original dataset contained many more labels (A1-A8, B1-B5, C1-C4), but filtering reduces it to only the most connected labels. This is particularly useful when working with large datasets where you want to focus on the most important relationships and reduce visual clutter from many small, weaker connections.\n\nWhat this shows:\n\nOnly top 8 labels by total flow are displayed (out of many more in the original data)\nFocuses attention on the strongest relationships\nUseful for large datasets where filtering helps identify key patterns\n\n(Image: Filtered Example)","category":"section"},{"location":"#Strength-based-Opacity","page":"Home","title":"Strength-based Opacity","text":"With alpha_by_value=true, opacity is scaled by strength for ribbons, arcs, and labels: ribbons by co-occurrence value, arcs and labels by total flow. Weaker connections and nodes become dimmer; one switch for consistent styling.\n\nWhat's different:\n\nalpha_by_value=true scales opacity by strength everywhere\nRibbons: higher co-occurrence value → more opaque\nArcs and labels: higher total flow → more opaque\nMinimum opacity 10% so nothing disappears\n\n(Image: Opacity Example)","category":"section"},{"location":"#Categorical-Colors","page":"Home","title":"Categorical Colors","text":"This example uses colorscheme=:categorical, which assigns a distinct color to each individual label rather than grouping by category. Every label gets its own unique color from the palette, making it easier to distinguish individual labels at the cost of losing the group-based color coding.\n\nWhat's different:\n\ncolorscheme=:categorical instead of :group\nEach label has its own distinct color\nNo color grouping by category\nUseful when you need to distinguish many individual labels\n\n(Image: Categorical Colors)","category":"section"},{"location":"#Custom-Layout","page":"Home","title":"Custom Layout","text":"What is a custom layout? A custom layout allows you to control how labels are arranged around the circle and how the arcs are sized. This example demonstrates several layout customizations: sorting by value (largest arcs first), adjusting the inner radius (how close ribbons start to the center), and changing the gap between arcs.\n\nWhat's different:\n\nsort_by=:value - Labels are sorted by their total flow (largest first), so the most connected labels get the largest arcs\ninner_radius=0.85 - Ribbons start closer to the center (default is 0.92), creating more space between ribbon endpoints and the outer circle\ngap_fraction=0.05 - Slightly larger gaps between arc segments (default is 0.03), making individual arcs more distinct\n\nThese settings help emphasize the most important labels and create a different visual balance compared to the default group-sorted layout.\n\n(Image: Custom Layout)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/mashu/ChordPlots.jl\")","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Explore the documentation to learn how to:\n\nGet started with your first chord diagram\nCreate co-occurrence data from various sources\nCustomize appearance with colors, layouts, and styling\nFilter and manage data for better visualizations\nUse advanced features for publication-quality figures","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MIT License","category":"section"},{"location":"user_guide/filtering/#Filtering-and-Data-Management","page":"Filtering","title":"Filtering and Data Management","text":"Filter data to reduce clutter and focus on important relationships.","category":"section"},{"location":"user_guide/filtering/#Choosing-a-Threshold","page":"Filtering","title":"Choosing a Threshold","text":"When filtering by value (e.g. filter_by_threshold or min_ribbon_value), it helps to inspect the distribution of co-occurrence values first. Use the built-in value histogram:\n\n# Single matrix: histogram of all co-occurrence values (upper triangle, non-zero)\nvalue_histogram(cooc)\n\n# Or on an existing axis\nvalue_histogram!(ax, cooc; bins = 30)\n\nFor multiple matrices (e.g. several donors), pass a vector to use the combined distribution:\n\nvalue_histogram([cooc1, cooc2, cooc3])\n\nYou can also get the raw values and plot them yourself:\n\nvals = cooccurrence_values(cooc)\n# Use vals to pick a threshold, then:\ncooc_filtered = filter_by_threshold(cooc, 5)\n# or chordplot!(ax, cooc; min_ribbon_value = 5)","category":"section"},{"location":"user_guide/filtering/#Filtering-Small-Segments","page":"Filtering","title":"Filtering Small Segments","text":"When you have many labels with small co-occurrence values, they can cluster together and overlap:\n\nchordplot!(ax, cooc;\n    min_arc_flow = 10  # Only show arcs with total flow >= 10\n)\n\nThis removes both the arc and its label, reducing clutter.\n\n<img src=\"assets/examples/filtered.png\" alt=\"Filtered Data\" style=\"max-width: 600px;\"/>\n\nWhat this shows: This example demonstrates filtering using filter_top_n(), which keeps only the top 8 labels by total flow (sum of all connections). The original dataset had many more labels (A1-A8, B1-B5, C1-C4), but only the 8 most connected labels are displayed. Filtering helps focus attention on the strongest relationships and is particularly useful when working with large datasets where many labels have only weak connections that would otherwise create visual clutter.","category":"section"},{"location":"user_guide/filtering/#Filtering-Before-Plotting","page":"Filtering","title":"Filtering Before Plotting","text":"Filter the data before plotting:\n\n# Keep only top N labels by total flow\ncooc_top = filter_top_n(cooc, 15)\n\n# Filter by minimum co-occurrence value\ncooc_filtered = filter_by_threshold(cooc, 5)\n\n# Normalize to frequencies\ncooc_norm = normalize(cooc)","category":"section"},{"location":"user_guide/filtering/#Filtering-Ribbons","page":"Filtering","title":"Filtering Ribbons","text":"Filter ribbons in the layout:\n\nlayout = compute_layout(cooc)\n\n# Filter by minimum value\nlayout_filtered = filter_ribbons(layout, 5)\n\n# Keep only top N ribbons\nlayout_top = filter_ribbons_top_n(layout, 20)","category":"section"},{"location":"user_guide/comparison/#Comparing-Matrices","page":"Comparing Matrices","title":"Comparing Matrices","text":"Compare two co-occurrence matrices to visualize what changed between conditions (e.g., before vs after treatment, wild-type vs knockout).","category":"section"},{"location":"user_guide/comparison/#Signed-Differences-with-Diverging-Colors","page":"Comparing Matrices","title":"Signed Differences with Diverging Colors","text":"Use diff() to compute the difference between two matrices and diff_colors() (or  diverging_colors()) to show increases vs decreases with a diverging colormap:\n\nusing CairoMakie, ChordPlots, DataFrames\n\n# Two conditions: before and after some intervention\ndf_before = DataFrame(\n    V = [\"V1\", \"V1\", \"V1\", \"V2\", \"V2\"],\n    D = [\"D1\", \"D1\", \"D2\", \"D1\", \"D2\"],\n    J = [\"J1\", \"J2\", \"J1\", \"J1\", \"J2\"]\n)\n\ndf_after = DataFrame(\n    V = [\"V1\", \"V2\", \"V2\", \"V2\", \"V2\"],\n    D = [\"D1\", \"D1\", \"D1\", \"D2\", \"D2\"],\n    J = [\"J1\", \"J1\", \"J2\", \"J1\", \"J2\"]\n)\n\ncooc_before = cooccurrence_matrix(df_before, [:V, :D, :J])\ncooc_after = cooccurrence_matrix(df_after, [:V, :D, :J])\n\n# Compute difference: after - before\n# Positive values = connections that INCREASED\n# Negative values = connections that DECREASED\nd = diff(cooc_after, cooc_before)\n\n# Plot with diverging colors: blue = decrease, red = increase\nfig, ax, plt = chordplot(d; colorscheme=diff_colors(d))\nsetup_chord_axis!(ax)\nax.title = \"Changes: After - Before\"\nfig\n\nThe colormap uses the same diverging scale for both ribbons and arcs:\n\nRibbons (connections):\n\nBlue: connections that decreased (negative difference)\nWhite/neutral: little or no change\nRed: connections that increased (positive difference)\n\nArcs (labels):\n\nBlue arc: label with overall depleted connections (net negative change)\nWhite arc: label with balanced changes (net ≈ zero)\nRed arc: label with overall enriched connections (net positive change)\n\nThis makes it easy to see at a glance which genes/labels gained or lost connections overall.","category":"section"},{"location":"user_guide/comparison/#Customizing-Colors","page":"Comparing Matrices","title":"Customizing Colors","text":"You can customize the diverging color scheme:\n\nusing Colors  # for RGB\n\n# Custom colors: green for enrichment, purple for depletion\ncs = diverging_colors(d; \n    negative = RGB(0.5, 0.0, 0.5),  # purple for depletion\n    neutral = RGB(1.0, 1.0, 1.0),   # white\n    positive = RGB(0.0, 0.5, 0.0)   # green for enrichment\n)\nchordplot(d; colorscheme=cs)","category":"section"},{"location":"user_guide/comparison/#Absolute-Differences","page":"Comparing Matrices","title":"Absolute Differences","text":"If you only care about the magnitude of change (not direction), use absolute=true:\n\n# All differences as positive values (magnitude only)\nd_abs = diff(cooc_after, cooc_before; absolute=true)\n\n# Use a sequential colormap like :Reds\nchordplot(d_abs; colorscheme=:Reds)","category":"section"},{"location":"user_guide/comparison/#Understanding-the-Direction","page":"Comparing Matrices","title":"Understanding the Direction","text":"The sign convention is diff(a, b) = a - b:\n\ndiff(after, before) Meaning\nPositive values Connection increased (after > before)\nNegative values Connection decreased (after < before)\nZero No change\n\nIf you want the opposite interpretation (positive = decrease), swap the arguments:\n\n# Positive = what was lost (before > after)\nd_loss = diff(cooc_before, cooc_after)","category":"section"},{"location":"user_guide/comparison/#Combined-Workflow","page":"Comparing Matrices","title":"Combined Workflow","text":"A typical comparison workflow:\n\nusing CairoMakie, ChordPlots, DataFrames\n\n# Load your data\ndf_control = ...  # control/baseline condition\ndf_treated = ...  # experimental condition\n\n# Build matrices\ncooc_control = cooccurrence_matrix(df_control, [:V, :D, :J])\ncooc_treated = cooccurrence_matrix(df_treated, [:V, :D, :J])\n\n# Create comparison figure\nfig = Figure(size=(1200, 500))\n\n# Original control\nax1 = Axis(fig[1,1], title=\"Control\")\nchordplot!(ax1, cooc_control)\nsetup_chord_axis!(ax1)\n\n# Treated condition  \nax2 = Axis(fig[1,2], title=\"Treated\")\nchordplot!(ax2, cooc_treated)\nsetup_chord_axis!(ax2)\n\n# Difference (treated - control)\nd = diff(cooc_treated, cooc_control)\nax3 = Axis(fig[1,3], title=\"Difference\\n(Blue↓ Red↑)\")\nchordplot!(ax3, d; colorscheme=diff_colors(d))\nsetup_chord_axis!(ax3)\n\nfig","category":"section"},{"location":"user_guide/comparison/#Notes","page":"Comparing Matrices","title":"Notes","text":"diff() normalizes both matrices before computing differences, so results are  in frequency space (fractions, not raw counts)\nMatrices can have different label sets; they are automatically aligned to the  union of all labels\nThe result is a NormalizedCoOccurrenceMatrix (does not sum to 1 since it's a  difference, not a probability distribution)\nArc widths in the difference plot are based on absolute difference magnitudes (so both increases and decreases appear as thick ribbons if the change is large)","category":"section"}]
}
